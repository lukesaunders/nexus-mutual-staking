// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BurnRequested extends ethereum.Event {
  get params(): BurnRequested__Params {
    return new BurnRequested__Params(this);
  }
}

export class BurnRequested__Params {
  _event: BurnRequested;

  constructor(event: BurnRequested) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Burned extends ethereum.Event {
  get params(): Burned__Params {
    return new Burned__Params(this);
  }
}

export class Burned__Params {
  _event: Burned;

  constructor(event: Burned) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get contractStakeBeforeBurn(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Deposited extends ethereum.Event {
  get params(): Deposited__Params {
    return new Deposited__Params(this);
  }
}

export class Deposited__Params {
  _event: Deposited;

  constructor(event: Deposited) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class MigratedMember extends ethereum.Event {
  get params(): MigratedMember__Params {
    return new MigratedMember__Params(this);
  }
}

export class MigratedMember__Params {
  _event: MigratedMember;

  constructor(event: MigratedMember) {
    this._event = event;
  }

  get member(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get memberIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class PendingActionsProcessed extends ethereum.Event {
  get params(): PendingActionsProcessed__Params {
    return new PendingActionsProcessed__Params(this);
  }
}

export class PendingActionsProcessed__Params {
  _event: PendingActionsProcessed;

  constructor(event: PendingActionsProcessed) {
    this._event = event;
  }

  get finished(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }
}

export class RewardRequested extends ethereum.Event {
  get params(): RewardRequested__Params {
    return new RewardRequested__Params(this);
  }
}

export class RewardRequested__Params {
  _event: RewardRequested;

  constructor(event: RewardRequested) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardWithdrawn extends ethereum.Event {
  get params(): RewardWithdrawn__Params {
    return new RewardWithdrawn__Params(this);
  }
}

export class RewardWithdrawn__Params {
  _event: RewardWithdrawn;

  constructor(event: RewardWithdrawn) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Rewarded extends ethereum.Event {
  get params(): Rewarded__Params {
    return new Rewarded__Params(this);
  }
}

export class Rewarded__Params {
  _event: Rewarded;

  constructor(event: Rewarded) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get contractStake(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Staked extends ethereum.Event {
  get params(): Staked__Params {
    return new Staked__Params(this);
  }
}

export class Staked__Params {
  _event: Staked;

  constructor(event: Staked) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class StakersMigrationCompleted extends ethereum.Event {
  get params(): StakersMigrationCompleted__Params {
    return new StakersMigrationCompleted__Params(this);
  }
}

export class StakersMigrationCompleted__Params {
  _event: StakersMigrationCompleted;

  constructor(event: StakersMigrationCompleted) {
    this._event = event;
  }

  get completed(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }

  get memberIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get stakeIndex(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class UnstakeRequested extends ethereum.Event {
  get params(): UnstakeRequested__Params {
    return new UnstakeRequested__Params(this);
  }
}

export class UnstakeRequested__Params {
  _event: UnstakeRequested;

  constructor(event: UnstakeRequested) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get unstakeAt(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Unstaked extends ethereum.Event {
  get params(): Unstaked__Params {
    return new Unstaked__Params(this);
  }
}

export class Unstaked__Params {
  _event: Unstaked;

  constructor(event: Unstaked) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Contract__burnResult {
  value0: BigInt;
  value1: BigInt;
  value2: Address;

  constructor(value0: BigInt, value1: BigInt, value2: Address) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    return map;
  }
}

export class Contract__rewardsResult {
  value0: BigInt;
  value1: BigInt;
  value2: Address;

  constructor(value0: BigInt, value1: BigInt, value2: Address) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    return map;
  }
}

export class Contract__unstakeRequestAtIndexResult {
  value0: BigInt;
  value1: BigInt;
  value2: Address;
  value3: Address;
  value4: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: Address,
    value3: Address,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromAddress(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }
}

export class Contract__unstakeRequestsResult {
  value0: BigInt;
  value1: BigInt;
  value2: Address;
  value3: Address;
  value4: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: Address,
    value3: Address,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromAddress(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }
}

export class Contract extends ethereum.SmartContract {
  static bind(address: Address): Contract {
    return new Contract("Contract", address);
  }

  MAX_EXPOSURE(): BigInt {
    let result = super.call("MAX_EXPOSURE", "MAX_EXPOSURE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MAX_EXPOSURE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MAX_EXPOSURE", "MAX_EXPOSURE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MIN_STAKE(): BigInt {
    let result = super.call("MIN_STAKE", "MIN_STAKE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MIN_STAKE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MIN_STAKE", "MIN_STAKE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MIN_UNSTAKE(): BigInt {
    let result = super.call("MIN_UNSTAKE", "MIN_UNSTAKE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MIN_UNSTAKE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MIN_UNSTAKE", "MIN_UNSTAKE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  UNSTAKE_LOCK_TIME(): BigInt {
    let result = super.call(
      "UNSTAKE_LOCK_TIME",
      "UNSTAKE_LOCK_TIME():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_UNSTAKE_LOCK_TIME(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "UNSTAKE_LOCK_TIME",
      "UNSTAKE_LOCK_TIME():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  burn(): Contract__burnResult {
    let result = super.call("burn", "burn():(uint256,uint256,address)", []);

    return new Contract__burnResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toAddress()
    );
  }

  try_burn(): ethereum.CallResult<Contract__burnResult> {
    let result = super.tryCall("burn", "burn():(uint256,uint256,address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Contract__burnResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toAddress()
      )
    );
  }

  contractStake(contractAddress: Address): BigInt {
    let result = super.call(
      "contractStake",
      "contractStake(address):(uint256)",
      [ethereum.Value.fromAddress(contractAddress)]
    );

    return result[0].toBigInt();
  }

  try_contractStake(contractAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "contractStake",
      "contractStake(address):(uint256)",
      [ethereum.Value.fromAddress(contractAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  contractStakerAtIndex(
    contractAddress: Address,
    stakerIndex: BigInt
  ): Address {
    let result = super.call(
      "contractStakerAtIndex",
      "contractStakerAtIndex(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(contractAddress),
        ethereum.Value.fromUnsignedBigInt(stakerIndex)
      ]
    );

    return result[0].toAddress();
  }

  try_contractStakerAtIndex(
    contractAddress: Address,
    stakerIndex: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "contractStakerAtIndex",
      "contractStakerAtIndex(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(contractAddress),
        ethereum.Value.fromUnsignedBigInt(stakerIndex)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  contractStakerCount(contractAddress: Address): BigInt {
    let result = super.call(
      "contractStakerCount",
      "contractStakerCount(address):(uint256)",
      [ethereum.Value.fromAddress(contractAddress)]
    );

    return result[0].toBigInt();
  }

  try_contractStakerCount(
    contractAddress: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "contractStakerCount",
      "contractStakerCount(address):(uint256)",
      [ethereum.Value.fromAddress(contractAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  contractStakersArray(contractAddress: Address): Array<Address> {
    let result = super.call(
      "contractStakersArray",
      "contractStakersArray(address):(address[])",
      [ethereum.Value.fromAddress(contractAddress)]
    );

    return result[0].toAddressArray();
  }

  try_contractStakersArray(
    contractAddress: Address
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "contractStakersArray",
      "contractStakersArray(address):(address[])",
      [ethereum.Value.fromAddress(contractAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  firstReward(): BigInt {
    let result = super.call("firstReward", "firstReward():(uint256)", []);

    return result[0].toBigInt();
  }

  try_firstReward(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("firstReward", "firstReward():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  hasPendingActions(): boolean {
    let result = super.call(
      "hasPendingActions",
      "hasPendingActions():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_hasPendingActions(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasPendingActions",
      "hasPendingActions():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasPendingBurns(): boolean {
    let result = super.call("hasPendingBurns", "hasPendingBurns():(bool)", []);

    return result[0].toBoolean();
  }

  try_hasPendingBurns(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasPendingBurns",
      "hasPendingBurns():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasPendingRewards(): boolean {
    let result = super.call(
      "hasPendingRewards",
      "hasPendingRewards():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_hasPendingRewards(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasPendingRewards",
      "hasPendingRewards():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasPendingUnstakeRequests(): boolean {
    let result = super.call(
      "hasPendingUnstakeRequests",
      "hasPendingUnstakeRequests():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_hasPendingUnstakeRequests(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasPendingUnstakeRequests",
      "hasPendingUnstakeRequests():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  initialized(): boolean {
    let result = super.call("initialized", "initialized():(bool)", []);

    return result[0].toBoolean();
  }

  try_initialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall("initialized", "initialized():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isContractStakeCalculated(): boolean {
    let result = super.call(
      "isContractStakeCalculated",
      "isContractStakeCalculated():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_isContractStakeCalculated(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isContractStakeCalculated",
      "isContractStakeCalculated():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastRewardId(): BigInt {
    let result = super.call("lastRewardId", "lastRewardId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastRewardId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("lastRewardId", "lastRewardId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastUnstakeRequestId(): BigInt {
    let result = super.call(
      "lastUnstakeRequestId",
      "lastUnstakeRequestId():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lastUnstakeRequestId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastUnstakeRequestId",
      "lastUnstakeRequestId():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  master(): Address {
    let result = super.call("master", "master():(address)", []);

    return result[0].toAddress();
  }

  try_master(): ethereum.CallResult<Address> {
    let result = super.tryCall("master", "master():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  migrateStakers(maxIterations: BigInt): boolean {
    let result = super.call(
      "migrateStakers",
      "migrateStakers(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(maxIterations)]
    );

    return result[0].toBoolean();
  }

  try_migrateStakers(maxIterations: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "migrateStakers",
      "migrateStakers(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(maxIterations)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  processPendingActions(maxIterations: BigInt): boolean {
    let result = super.call(
      "processPendingActions",
      "processPendingActions(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(maxIterations)]
    );

    return result[0].toBoolean();
  }

  try_processPendingActions(
    maxIterations: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "processPendingActions",
      "processPendingActions(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(maxIterations)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  processedToStakerIndex(): BigInt {
    let result = super.call(
      "processedToStakerIndex",
      "processedToStakerIndex():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_processedToStakerIndex(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "processedToStakerIndex",
      "processedToStakerIndex():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewards(param0: BigInt): Contract__rewardsResult {
    let result = super.call(
      "rewards",
      "rewards(uint256):(uint256,uint256,address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new Contract__rewardsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toAddress()
    );
  }

  try_rewards(param0: BigInt): ethereum.CallResult<Contract__rewardsResult> {
    let result = super.tryCall(
      "rewards",
      "rewards(uint256):(uint256,uint256,address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Contract__rewardsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toAddress()
      )
    );
  }

  stakerContractAtIndex(staker: Address, contractIndex: BigInt): Address {
    let result = super.call(
      "stakerContractAtIndex",
      "stakerContractAtIndex(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromUnsignedBigInt(contractIndex)
      ]
    );

    return result[0].toAddress();
  }

  try_stakerContractAtIndex(
    staker: Address,
    contractIndex: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "stakerContractAtIndex",
      "stakerContractAtIndex(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromUnsignedBigInt(contractIndex)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  stakerContractCount(staker: Address): BigInt {
    let result = super.call(
      "stakerContractCount",
      "stakerContractCount(address):(uint256)",
      [ethereum.Value.fromAddress(staker)]
    );

    return result[0].toBigInt();
  }

  try_stakerContractCount(staker: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerContractCount",
      "stakerContractCount(address):(uint256)",
      [ethereum.Value.fromAddress(staker)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakerContractPendingUnstakeTotal(
    staker: Address,
    contractAddress: Address
  ): BigInt {
    let result = super.call(
      "stakerContractPendingUnstakeTotal",
      "stakerContractPendingUnstakeTotal(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(contractAddress)
      ]
    );

    return result[0].toBigInt();
  }

  try_stakerContractPendingUnstakeTotal(
    staker: Address,
    contractAddress: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerContractPendingUnstakeTotal",
      "stakerContractPendingUnstakeTotal(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(contractAddress)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakerContractStake(staker: Address, contractAddress: Address): BigInt {
    let result = super.call(
      "stakerContractStake",
      "stakerContractStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(contractAddress)
      ]
    );

    return result[0].toBigInt();
  }

  try_stakerContractStake(
    staker: Address,
    contractAddress: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerContractStake",
      "stakerContractStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(contractAddress)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakerContractsArray(staker: Address): Array<Address> {
    let result = super.call(
      "stakerContractsArray",
      "stakerContractsArray(address):(address[])",
      [ethereum.Value.fromAddress(staker)]
    );

    return result[0].toAddressArray();
  }

  try_stakerContractsArray(
    staker: Address
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "stakerContractsArray",
      "stakerContractsArray(address):(address[])",
      [ethereum.Value.fromAddress(staker)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  stakerDeposit(staker: Address): BigInt {
    let result = super.call(
      "stakerDeposit",
      "stakerDeposit(address):(uint256)",
      [ethereum.Value.fromAddress(staker)]
    );

    return result[0].toBigInt();
  }

  try_stakerDeposit(staker: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerDeposit",
      "stakerDeposit(address):(uint256)",
      [ethereum.Value.fromAddress(staker)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakerMaxWithdrawable(stakerAddress: Address): BigInt {
    let result = super.call(
      "stakerMaxWithdrawable",
      "stakerMaxWithdrawable(address):(uint256)",
      [ethereum.Value.fromAddress(stakerAddress)]
    );

    return result[0].toBigInt();
  }

  try_stakerMaxWithdrawable(
    stakerAddress: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerMaxWithdrawable",
      "stakerMaxWithdrawable(address):(uint256)",
      [ethereum.Value.fromAddress(stakerAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakerReward(staker: Address): BigInt {
    let result = super.call("stakerReward", "stakerReward(address):(uint256)", [
      ethereum.Value.fromAddress(staker)
    ]);

    return result[0].toBigInt();
  }

  try_stakerReward(staker: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "stakerReward",
      "stakerReward(address):(uint256)",
      [ethereum.Value.fromAddress(staker)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenController(): Address {
    let result = super.call(
      "tokenController",
      "tokenController():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_tokenController(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "tokenController",
      "tokenController():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  unstakeRequestAtIndex(
    unstakeRequestId: BigInt
  ): Contract__unstakeRequestAtIndexResult {
    let result = super.call(
      "unstakeRequestAtIndex",
      "unstakeRequestAtIndex(uint256):(uint256,uint256,address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(unstakeRequestId)]
    );

    return new Contract__unstakeRequestAtIndexResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toAddress(),
      result[3].toAddress(),
      result[4].toBigInt()
    );
  }

  try_unstakeRequestAtIndex(
    unstakeRequestId: BigInt
  ): ethereum.CallResult<Contract__unstakeRequestAtIndexResult> {
    let result = super.tryCall(
      "unstakeRequestAtIndex",
      "unstakeRequestAtIndex(uint256):(uint256,uint256,address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(unstakeRequestId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Contract__unstakeRequestAtIndexResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toAddress(),
        value[3].toAddress(),
        value[4].toBigInt()
      )
    );
  }

  unstakeRequests(param0: BigInt): Contract__unstakeRequestsResult {
    let result = super.call(
      "unstakeRequests",
      "unstakeRequests(uint256):(uint256,uint256,address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new Contract__unstakeRequestsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toAddress(),
      result[3].toAddress(),
      result[4].toBigInt()
    );
  }

  try_unstakeRequests(
    param0: BigInt
  ): ethereum.CallResult<Contract__unstakeRequestsResult> {
    let result = super.tryCall(
      "unstakeRequests",
      "unstakeRequests(uint256):(uint256,uint256,address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Contract__unstakeRequestsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toAddress(),
        value[3].toAddress(),
        value[4].toBigInt()
      )
    );
  }
}

export class ChangeDependentContractAddressCall extends ethereum.Call {
  get inputs(): ChangeDependentContractAddressCall__Inputs {
    return new ChangeDependentContractAddressCall__Inputs(this);
  }

  get outputs(): ChangeDependentContractAddressCall__Outputs {
    return new ChangeDependentContractAddressCall__Outputs(this);
  }
}

export class ChangeDependentContractAddressCall__Inputs {
  _call: ChangeDependentContractAddressCall;

  constructor(call: ChangeDependentContractAddressCall) {
    this._call = call;
  }
}

export class ChangeDependentContractAddressCall__Outputs {
  _call: ChangeDependentContractAddressCall;

  constructor(call: ChangeDependentContractAddressCall) {
    this._call = call;
  }
}

export class ChangeMasterAddressCall extends ethereum.Call {
  get inputs(): ChangeMasterAddressCall__Inputs {
    return new ChangeMasterAddressCall__Inputs(this);
  }

  get outputs(): ChangeMasterAddressCall__Outputs {
    return new ChangeMasterAddressCall__Outputs(this);
  }
}

export class ChangeMasterAddressCall__Inputs {
  _call: ChangeMasterAddressCall;

  constructor(call: ChangeMasterAddressCall) {
    this._call = call;
  }

  get masterAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ChangeMasterAddressCall__Outputs {
  _call: ChangeMasterAddressCall;

  constructor(call: ChangeMasterAddressCall) {
    this._call = call;
  }
}

export class DepositAndStakeCall extends ethereum.Call {
  get inputs(): DepositAndStakeCall__Inputs {
    return new DepositAndStakeCall__Inputs(this);
  }

  get outputs(): DepositAndStakeCall__Outputs {
    return new DepositAndStakeCall__Outputs(this);
  }
}

export class DepositAndStakeCall__Inputs {
  _call: DepositAndStakeCall;

  constructor(call: DepositAndStakeCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _contracts(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get _stakes(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }
}

export class DepositAndStakeCall__Outputs {
  _call: DepositAndStakeCall;

  constructor(call: DepositAndStakeCall) {
    this._call = call;
  }
}

export class MigrateStakersCall extends ethereum.Call {
  get inputs(): MigrateStakersCall__Inputs {
    return new MigrateStakersCall__Inputs(this);
  }

  get outputs(): MigrateStakersCall__Outputs {
    return new MigrateStakersCall__Outputs(this);
  }
}

export class MigrateStakersCall__Inputs {
  _call: MigrateStakersCall;

  constructor(call: MigrateStakersCall) {
    this._call = call;
  }

  get maxIterations(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class MigrateStakersCall__Outputs {
  _call: MigrateStakersCall;

  constructor(call: MigrateStakersCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ProcessPendingActionsCall extends ethereum.Call {
  get inputs(): ProcessPendingActionsCall__Inputs {
    return new ProcessPendingActionsCall__Inputs(this);
  }

  get outputs(): ProcessPendingActionsCall__Outputs {
    return new ProcessPendingActionsCall__Outputs(this);
  }
}

export class ProcessPendingActionsCall__Inputs {
  _call: ProcessPendingActionsCall;

  constructor(call: ProcessPendingActionsCall) {
    this._call = call;
  }

  get maxIterations(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class ProcessPendingActionsCall__Outputs {
  _call: ProcessPendingActionsCall;

  constructor(call: ProcessPendingActionsCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class PushBurnCall extends ethereum.Call {
  get inputs(): PushBurnCall__Inputs {
    return new PushBurnCall__Inputs(this);
  }

  get outputs(): PushBurnCall__Outputs {
    return new PushBurnCall__Outputs(this);
  }
}

export class PushBurnCall__Inputs {
  _call: PushBurnCall;

  constructor(call: PushBurnCall) {
    this._call = call;
  }

  get contractAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class PushBurnCall__Outputs {
  _call: PushBurnCall;

  constructor(call: PushBurnCall) {
    this._call = call;
  }
}

export class PushRewardCall extends ethereum.Call {
  get inputs(): PushRewardCall__Inputs {
    return new PushRewardCall__Inputs(this);
  }

  get outputs(): PushRewardCall__Outputs {
    return new PushRewardCall__Outputs(this);
  }
}

export class PushRewardCall__Inputs {
  _call: PushRewardCall;

  constructor(call: PushRewardCall) {
    this._call = call;
  }

  get contractAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class PushRewardCall__Outputs {
  _call: PushRewardCall;

  constructor(call: PushRewardCall) {
    this._call = call;
  }
}

export class RequestUnstakeCall extends ethereum.Call {
  get inputs(): RequestUnstakeCall__Inputs {
    return new RequestUnstakeCall__Inputs(this);
  }

  get outputs(): RequestUnstakeCall__Outputs {
    return new RequestUnstakeCall__Outputs(this);
  }
}

export class RequestUnstakeCall__Inputs {
  _call: RequestUnstakeCall;

  constructor(call: RequestUnstakeCall) {
    this._call = call;
  }

  get _contracts(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get _amounts(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray();
  }

  get _insertAfter(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class RequestUnstakeCall__Outputs {
  _call: RequestUnstakeCall;

  constructor(call: RequestUnstakeCall) {
    this._call = call;
  }
}

export class UpdateUintParametersCall extends ethereum.Call {
  get inputs(): UpdateUintParametersCall__Inputs {
    return new UpdateUintParametersCall__Inputs(this);
  }

  get outputs(): UpdateUintParametersCall__Outputs {
    return new UpdateUintParametersCall__Outputs(this);
  }
}

export class UpdateUintParametersCall__Inputs {
  _call: UpdateUintParametersCall;

  constructor(call: UpdateUintParametersCall) {
    this._call = call;
  }

  get code(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UpdateUintParametersCall__Outputs {
  _call: UpdateUintParametersCall;

  constructor(call: UpdateUintParametersCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawRewardCall extends ethereum.Call {
  get inputs(): WithdrawRewardCall__Inputs {
    return new WithdrawRewardCall__Inputs(this);
  }

  get outputs(): WithdrawRewardCall__Outputs {
    return new WithdrawRewardCall__Outputs(this);
  }
}

export class WithdrawRewardCall__Inputs {
  _call: WithdrawRewardCall;

  constructor(call: WithdrawRewardCall) {
    this._call = call;
  }

  get stakerAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class WithdrawRewardCall__Outputs {
  _call: WithdrawRewardCall;

  constructor(call: WithdrawRewardCall) {
    this._call = call;
  }
}
